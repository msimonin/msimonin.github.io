<!DOCTYPE html>
<meta charset="utf-8">
<style>
  .counter0{
    color: blue;
  }
  .counter1{
    color: red;
  }
</style>
<link rel="stylesheet" type="text/css" href="stylesheets/bootstrap.min.css">
<body>
  <div class="container">
    <h1>The 7 colors game</h1>
    <p>
    Originally from <a href="http://people.irisa.fr/Anne-Cecile.Orgerie/">Anne-CÃ©cile Orgerie</a>
    and <a href=http://people.irisa.fr/Martin.Quinson/>Martin Quinson</a> for a C programming course.
    Rewritten here in <a href="https://d3js.org">D3js</a> (without AI).
    </p>
    <div class="row">
    <div class="col-md-1 counter0">Player 1 : <span id="counter0"></span></div>
    <div class="col-md-1 counter1">Player 2 : <span id="counter1"></span></div>
    </div>
    <div id="graph"></div>

    <div class="footer">
      Matthieu Simonin
    </div>
</div>
  <script src="js/underscore-min.js"></script>
  <script src="js/d3.min.js"></script>
  <script>
    var COLORS=7;
    var NB = 10;

    // in pixel
    var SIZE = 500;
    var SQUARE = SIZE/NB;

    var datas = [];

    _.range(NB).forEach(function(y){
      _.range(NB).forEach(function(x) {
        datas.push({
            value : Math.floor(COLORS * Math.random()),
            x: x,
            y: y,
            owner: -1
          });
        })
    });
    datas[0].owner = 0;
    var zone = [
      [datas[0]],
      [datas[NB * NB - 1]]
    ];

    var player = 0;
    var scale = d3.scale.linear().domain([0, NB]).range([0, SIZE]);
    var color = d3.scale.category10();

    var svg = d3.select("#graph")
      .append("svg")
      .attr("width", SIZE)
      .attr("height", SIZE);

    var svgDatas = svg.selectAll("rect").data(datas);

    svgDatas.enter()
      .append("rect")
      .attr("x", function(d){return scale(d.x)})
      .attr("y", function(d){return scale(d.y)})
      .attr("width", SQUARE)
      .attr("height", SQUARE);

      updateCounter()
      draw();

      function draw() {
        svgDatas
        .style("fill", function(d){
            if (_.contains(zone[0], d))
              return "blue";
            if (_.contains(zone[1], d))
              return "red";
            return color(d.value)})
          .style("opacity", function(d){
            if (_.contains(zone[0], d))
              return 1;
            if (_.contains(zone[1], d))
              return 1;
            return 0.6
          })
          .on("mouseover", function(d){
            var color = "red";
            if (canExtend(d, player,d)) {
              color = "green";
            }
            d3.select(this)
              .style("stroke", color)
              .style("stroke-width", "5");
          })
          .on("mouseout", function(d) {
            d3.select(this)
              .style("stroke-width", 0);
          })
          .on("click", function(d){
            if (canExtend(d, player,d)) {
              extend(d, player);
              draw();
              updateCounter();
              player = 1 - player;
            }
          });
        };

      function updateCounter(){
        d3.select("#counter0").text(" " + ((zone[0].length / (NB * NB)) * 100).toFixed(1) + "%");
        d3.select("#counter1").text(" " + ((zone[1].length / (NB * NB)) * 100).toFixed(1) + "%");
      }

      //true iff d is one of the neighbour of
      // already controlled zone.
      function neighbour(d, player) {
        return zone[player].some(function(z) {
          var test =
          ((z.x === d.x && z.y  ===  d.y + 1)
          ||
          (z.x === d.x && z.y  ===  d.y - 1)
          ||
          (z.x === d.x - 1 && z.y === d.y)
          ||
          (z.x === d.x + 1 && z.y === d.y));
          return test;
        });
      }

      // can the zone be extended with n according to the hovered d cells
      // for player player
      function canExtend(n, player, d) {
        return neighbour(n, player) && n.owner < 0 && n.value == d.value;
      }

      // extends the zone for player player with all the cells with the
      // same value as d
      function extend(d, player) {
        var nodes = datas.filter(function(n){return canExtend(n,player,d)});
        while (nodes.length != 0) {
          nodes.forEach(function(d) {
            d.owner = player;
            zone[player].push(d);
          });
          nodes = datas.filter(function(n){return canExtend(n,player,d)});
        }
        draw();
      }

  </script>
</body>
